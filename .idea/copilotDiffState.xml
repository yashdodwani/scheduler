<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic.ini" />
              <option name="originalContent" value="# A generic, single database configuration.&#10;&#10;[alembic]&#10;# path to migration scripts.&#10;# this is typically a path given in POSIX (e.g. forward slashes)&#10;# format, relative to the token %(here)s which refers to the location of this&#10;# ini file&#10;script_location = %(here)s/alembic&#10;&#10;# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s&#10;# Uncomment the line below if you want the files to be prepended with date and time&#10;# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file&#10;# for all available tokens&#10;# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s&#10;&#10;# sys.path path, will be prepended to sys.path if present.&#10;# defaults to the current working directory.  for multiple paths, the path separator&#10;# is defined by &quot;path_separator&quot; below.&#10;prepend_sys_path = .&#10;&#10;&#10;# timezone to use when rendering the date within the migration file&#10;# as well as the filename.&#10;# If specified, requires the python&gt;=3.9 or backports.zoneinfo library and tzdata library.&#10;# Any required deps can installed by adding `alembic[tz]` to the pip requirements&#10;# string value is passed to ZoneInfo()&#10;# leave blank for localtime&#10;# timezone =&#10;&#10;# max length of characters to apply to the &quot;slug&quot; field&#10;# truncate_slug_length = 40&#10;&#10;# set to 'true' to run the environment during&#10;# the 'revision' command, regardless of autogenerate&#10;# revision_environment = false&#10;&#10;# set to 'true' to allow .pyc and .pyo files without&#10;# a source .py file to be detected as revisions in the&#10;# versions/ directory&#10;# sourceless = false&#10;&#10;# version location specification; This defaults&#10;# to &lt;script_location&gt;/versions.  When using multiple version&#10;# directories, initial revisions must be specified with --version-path.&#10;# The path separator used here should be the separator specified by &quot;path_separator&quot;&#10;# below.&#10;# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions&#10;&#10;# path_separator; This indicates what character is used to split lists of file&#10;# paths, including version_locations and prepend_sys_path within configparser&#10;# files such as alembic.ini.&#10;# The default rendered in new alembic.ini files is &quot;os&quot;, which uses os.pathsep&#10;# to provide os-dependent path splitting.&#10;#&#10;# Note that in order to support legacy alembic.ini files, this default does NOT&#10;# take place if path_separator is not present in alembic.ini.  If this&#10;# option is omitted entirely, fallback logic is as follows:&#10;#&#10;# 1. Parsing of the version_locations option falls back to using the legacy&#10;#    &quot;version_path_separator&quot; key, which if absent then falls back to the legacy&#10;#    behavior of splitting on spaces and/or commas.&#10;# 2. Parsing of the prepend_sys_path option falls back to the legacy&#10;#    behavior of splitting on spaces, commas, or colons.&#10;#&#10;# Valid values for path_separator are:&#10;#&#10;# path_separator = :&#10;# path_separator = ;&#10;# path_separator = space&#10;# path_separator = newline&#10;#&#10;# Use os.pathsep. Default configuration used for new projects.&#10;path_separator = os&#10;&#10;# set to 'true' to search source files recursively&#10;# in each &quot;version_locations&quot; directory&#10;# new in Alembic version 1.10&#10;# recursive_version_locations = false&#10;&#10;# the output encoding used when revision files&#10;# are written from script.py.mako&#10;# output_encoding = utf-8&#10;&#10;# database URL.  This is consumed by the user-maintained env.py script only.&#10;# other means of configuring database URLs may be customized within the env.py&#10;# file.&#10;sqlalchemy.url = driver://user:pass@localhost/dbname&#10;&#10;&#10;[post_write_hooks]&#10;# post_write_hooks defines scripts or Python functions that are run&#10;# on newly generated revision scripts.  See the documentation for further&#10;# detail and examples&#10;&#10;# format using &quot;black&quot; - use the console_scripts runner, against the &quot;black&quot; entrypoint&#10;# hooks = black&#10;# black.type = console_scripts&#10;# black.entrypoint = black&#10;# black.options = -l 79 REVISION_SCRIPT_FILENAME&#10;&#10;# lint with attempts to fix using &quot;ruff&quot; - use the module runner, against the &quot;ruff&quot; module&#10;# hooks = ruff&#10;# ruff.type = module&#10;# ruff.module = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Alternatively, use the exec runner to execute a binary found on your PATH&#10;# hooks = ruff&#10;# ruff.type = exec&#10;# ruff.executable = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Logging configuration.  This is also consumed by the user-maintained&#10;# env.py script only.&#10;[loggers]&#10;keys = root,sqlalchemy,alembic&#10;&#10;[handlers]&#10;keys = console&#10;&#10;[formatters]&#10;keys = generic&#10;&#10;[logger_root]&#10;level = WARNING&#10;handlers = console&#10;qualname =&#10;&#10;[logger_sqlalchemy]&#10;level = WARNING&#10;handlers =&#10;qualname = sqlalchemy.engine&#10;&#10;[logger_alembic]&#10;level = INFO&#10;handlers =&#10;qualname = alembic&#10;&#10;[handler_console]&#10;class = StreamHandler&#10;args = (sys.stderr,)&#10;level = NOTSET&#10;formatter = generic&#10;&#10;[formatter_generic]&#10;format = %(levelname)-5.5s [%(name)s] %(message)s&#10;datefmt = %H:%M:%S&#10;" />
              <option name="updatedContent" value="# A generic, single database configuration.&#10;&#10;[alembic]&#10;# path to migration scripts.&#10;# this is typically a path given in POSIX (e.g. forward slashes)&#10;# format, relative to the token %(here)s which refers to the location of this&#10;# ini file&#10;script_location = %(here)s/alembic&#10;&#10;# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s&#10;# Uncomment the line below if you want the files to be prepended with date and time&#10;# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file&#10;# for all available tokens&#10;# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s&#10;&#10;# sys.path path, will be prepended to sys.path if present.&#10;# defaults to the current working directory.  for multiple paths, the path separator&#10;# is defined by &quot;path_separator&quot; below.&#10;prepend_sys_path = .&#10;&#10;&#10;# timezone to use when rendering the date within the migration file&#10;# as well as the filename.&#10;# If specified, requires the python&gt;=3.9 or backports.zoneinfo library and tzdata library.&#10;# Any required deps can installed by adding `alembic[tz]` to the pip requirements&#10;# string value is passed to ZoneInfo()&#10;# leave blank for localtime&#10;# timezone =&#10;&#10;# max length of characters to apply to the &quot;slug&quot; field&#10;# truncate_slug_length = 40&#10;&#10;# set to 'true' to run the environment during&#10;# the 'revision' command, regardless of autogenerate&#10;# revision_environment = false&#10;&#10;# set to 'true' to allow .pyc and .pyo files without&#10;# a source .py file to be detected as revisions in the&#10;# versions/ directory&#10;# sourceless = false&#10;&#10;# version location specification; This defaults&#10;# to &lt;script_location&gt;/versions.  When using multiple version&#10;# directories, initial revisions must be specified with --version-path.&#10;# The path separator used here should be the separator specified by &quot;path_separator&quot;&#10;# below.&#10;# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions&#10;&#10;# path_separator; This indicates what character is used to split lists of file&#10;# paths, including version_locations and prepend_sys_path within configparser&#10;# files such as alembic.ini.&#10;# The default rendered in new alembic.ini files is &quot;os&quot;, which uses os.pathsep&#10;# to provide os-dependent path splitting.&#10;#&#10;# Note that in order to support legacy alembic.ini files, this default does NOT&#10;# take place if path_separator is not present in alembic.ini.  If this&#10;# option is omitted entirely, fallback logic is as follows:&#10;#&#10;# 1. Parsing of the version_locations option falls back to using the legacy&#10;#    &quot;version_path_separator&quot; key, which if absent then falls back to the legacy&#10;#    behavior of splitting on spaces and/or commas.&#10;# 2. Parsing of the prepend_sys_path option falls back to the legacy&#10;#    behavior of splitting on spaces, commas, or colons.&#10;#&#10;# Valid values for path_separator are:&#10;#&#10;# path_separator = :&#10;# path_separator = ;&#10;# path_separator = space&#10;# path_separator = newline&#10;#&#10;# Use os.pathsep. Default configuration used for new projects.&#10;path_separator = os&#10;&#10;# set to 'true' to search source files recursively&#10;# in each &quot;version_locations&quot; directory&#10;# new in Alembic version 1.10&#10;# recursive_version_locations = false&#10;&#10;# the output encoding used when revision files&#10;# are written from script.py.mako&#10;# output_encoding = utf-8&#10;&#10;# database URL.  This is consumed by the user-maintained env.py script only.&#10;# other means of configuring database URLs may be customized within the env.py&#10;# file.&#10;sqlalchemy.url =&#10;&#10;[post_write_hooks]&#10;# post_write_hooks defines scripts or Python functions that are run&#10;# on newly generated revision scripts.  See the documentation for further&#10;# detail and examples&#10;&#10;# format using &quot;black&quot; - use the console_scripts runner, against the &quot;black&quot; entrypoint&#10;# hooks = black&#10;# black.type = console_scripts&#10;# black.entrypoint = black&#10;# black.options = -l 79 REVISION_SCRIPT_FILENAME&#10;&#10;# lint with attempts to fix using &quot;ruff&quot; - use the module runner, against the &quot;ruff&quot; module&#10;# hooks = ruff&#10;# ruff.type = module&#10;# ruff.module = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Alternatively, use the exec runner to execute a binary found on your PATH&#10;# hooks = ruff&#10;# ruff.type = exec&#10;# ruff.executable = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Logging configuration.  This is also consumed by the user-maintained&#10;# env.py script only.&#10;[loggers]&#10;keys = root,sqlalchemy,alembic&#10;&#10;[handlers]&#10;keys = console&#10;&#10;[formatters]&#10;keys = generic&#10;&#10;[logger_root]&#10;level = WARNING&#10;handlers = console&#10;qualname =&#10;&#10;[logger_sqlalchemy]&#10;level = WARNING&#10;handlers =&#10;qualname = sqlalchemy.engine&#10;&#10;[logger_alembic]&#10;level = INFO&#10;handlers =&#10;qualname = alembic&#10;&#10;[handler_console]&#10;class = StreamHandler&#10;args = (sys.stderr,)&#10;level = NOTSET&#10;formatter = generic&#10;&#10;[formatter_generic]&#10;format = %(levelname)-5.5s [%(name)s] %(message)s&#10;datefmt = %H:%M:%S" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/alembic/env.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/env.py" />
              <option name="originalContent" value="from logging.config import fileConfig&#10;&#10;from sqlalchemy import engine_from_config&#10;from sqlalchemy import pool&#10;&#10;from alembic import context&#10;&#10;# this is the Alembic Config object, which provides&#10;# access to the values within the .ini file in use.&#10;config = context.config&#10;&#10;# Interpret the config file for Python logging.&#10;# This line sets up loggers basically.&#10;if config.config_file_name is not None:&#10;    fileConfig(config.config_file_name)&#10;&#10;# add your model's MetaData object here&#10;# for 'autogenerate' support&#10;# from myapp import mymodel&#10;# target_metadata = mymodel.Base.metadata&#10;target_metadata = None&#10;&#10;# other values from the config, defined by the needs of env.py,&#10;# can be acquired:&#10;# my_important_option = config.get_main_option(&quot;my_important_option&quot;)&#10;# ... etc.&#10;&#10;&#10;def run_migrations_offline() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'offline' mode.&#10;&#10;    This configures the context with just a URL&#10;    and not an Engine, though an Engine is acceptable&#10;    here as well.  By skipping the Engine creation&#10;    we don't even need a DBAPI to be available.&#10;&#10;    Calls to context.execute() here emit the given string to the&#10;    script output.&#10;&#10;    &quot;&quot;&quot;&#10;    url = config.get_main_option(&quot;sqlalchemy.url&quot;)&#10;    context.configure(&#10;        url=url,&#10;        target_metadata=target_metadata,&#10;        literal_binds=True,&#10;        dialect_opts={&quot;paramstyle&quot;: &quot;named&quot;},&#10;    )&#10;&#10;    with context.begin_transaction():&#10;        context.run_migrations()&#10;&#10;&#10;def run_migrations_online() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'online' mode.&#10;&#10;    In this scenario we need to create an Engine&#10;    and associate a connection with the context.&#10;&#10;    &quot;&quot;&quot;&#10;    connectable = engine_from_config(&#10;        config.get_section(config.config_ini_section, {}),&#10;        prefix=&quot;sqlalchemy.&quot;,&#10;        poolclass=pool.NullPool,&#10;    )&#10;&#10;    with connectable.connect() as connection:&#10;        context.configure(&#10;            connection=connection, target_metadata=target_metadata&#10;        )&#10;&#10;        with context.begin_transaction():&#10;            context.run_migrations()&#10;&#10;&#10;if context.is_offline_mode():&#10;    run_migrations_offline()&#10;else:&#10;    run_migrations_online()&#10;" />
              <option name="updatedContent" value="from logging.config import fileConfig&#10;&#10;from sqlalchemy import engine_from_config&#10;from sqlalchemy import pool&#10;&#10;from alembic import context&#10;import sys&#10;import os&#10;&#10;# this is the Alembic Config object, which provides&#10;# access to the values within the .ini file in use.&#10;config = context.config&#10;&#10;sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))&#10;from config import SQLALCHEMY_DATABASE_URL&#10;from models.db_models import Base  # Import your Base&#10;config.set_main_option('sqlalchemy.url', SQLALCHEMY_DATABASE_URL)&#10;&#10;# Interpret the config file for Python logging.&#10;# This line sets up loggers basically.&#10;if config.config_file_name is not None:&#10;    fileConfig(config.config_file_name)&#10;&#10;# add your model's MetaData object here&#10;# for 'autogenerate' support&#10;# from myapp import mymodel&#10;# target_metadata = mymodel.Base.metadata&#10;target_metadata = Base.metadata&#10;&#10;# other values from the config, defined by the needs of env.py,&#10;# can be acquired:&#10;# my_important_option = config.get_main_option(&quot;my_important_option&quot;)&#10;# ... etc.&#10;&#10;&#10;def run_migrations_offline() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'offline' mode.&#10;&#10;    This configures the context with just a URL&#10;    and not an Engine, though an Engine is acceptable&#10;    here as well.  By skipping the Engine creation&#10;    we don't even need a DBAPI to be available.&#10;&#10;    Calls to context.execute() here emit the given string to the&#10;    script output.&#10;&#10;    &quot;&quot;&quot;&#10;    url = config.get_main_option(&quot;sqlalchemy.url&quot;)&#10;    context.configure(&#10;        url=url,&#10;        target_metadata=target_metadata,&#10;        literal_binds=True,&#10;        dialect_opts={&quot;paramstyle&quot;: &quot;named&quot;},&#10;    )&#10;&#10;    with context.begin_transaction():&#10;        context.run_migrations()&#10;&#10;&#10;def run_migrations_online() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'online' mode.&#10;&#10;    In this scenario we need to create an Engine&#10;    and associate a connection with the context.&#10;&#10;    &quot;&quot;&quot;&#10;    connectable = engine_from_config(&#10;        config.get_section(config.config_ini_section, {}),&#10;        prefix=&quot;sqlalchemy.&quot;,&#10;        poolclass=pool.NullPool,&#10;    )&#10;&#10;    with connectable.connect() as connection:&#10;        context.configure(&#10;            connection=connection, target_metadata=target_metadata&#10;        )&#10;&#10;        with context.begin_transaction():&#10;            context.run_migrations()&#10;&#10;&#10;if context.is_offline_mode():&#10;    run_migrations_offline()&#10;else:&#10;    run_migrations_online()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/models/db_models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/db_models.py" />
              <option name="originalContent" value="from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from datetime import datetime&#10;&#10;Base = declarative_base()&#10;&#10;class User(Base):&#10;    __tablename__ = &quot;users&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    email = Column(String, unique=True, index=True)&#10;    hashed_password = Column(String)&#10;    telegram_user_id = Column(String, nullable=True)&#10;    is_active = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    notification_time = Column(String, default=&quot;08:00&quot;)  # Format: HH:MM (24-hour)&#10;    notify_one_day_before = Column(Boolean, default=False)&#10;&#10;class Event(Base):&#10;    __tablename__ = &quot;events&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    user_id = Column(Integer, index=True)&#10;    title = Column(String)&#10;    description = Column(Text)&#10;    event_date = Column(DateTime)&#10;    event_time = Column(String)&#10;    source_file = Column(String)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;" />
              <option name="updatedContent" value="from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean, ForeignKey&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;from datetime import datetime&#10;&#10;Base = declarative_base()&#10;&#10;class Company(Base):&#10;    __tablename__ = &quot;companies&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    name = Column(String, unique=True, index=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    contacts = relationship(&quot;CompanyContact&quot;, back_populates=&quot;company&quot;)&#10;    users = relationship(&quot;User&quot;, back_populates=&quot;company&quot;)&#10;&#10;class CompanyContact(Base):&#10;    __tablename__ = &quot;company_contacts&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    company_id = Column(Integer, ForeignKey(&quot;companies.id&quot;))&#10;    email = Column(String, nullable=True)&#10;    telegram_user_id = Column(String, nullable=True)&#10;    company = relationship(&quot;Company&quot;, back_populates=&quot;contacts&quot;)&#10;&#10;class User(Base):&#10;    __tablename__ = &quot;users&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    email = Column(String, unique=True, index=True)&#10;    hashed_password = Column(String)&#10;    telegram_user_id = Column(String, nullable=True)&#10;    is_active = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    notification_time = Column(String, default=&quot;08:00&quot;)  # Format: HH:MM (24-hour)&#10;    notify_one_day_before = Column(Boolean, default=False)&#10;    role = Column(String, default=&quot;person&quot;)  # 'person', 'company_admin', 'company_member'&#10;    company_id = Column(Integer, ForeignKey(&quot;companies.id&quot;), nullable=True)&#10;    company = relationship(&quot;Company&quot;, back_populates=&quot;users&quot;)&#10;&#10;class Event(Base):&#10;    __tablename__ = &quot;events&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    user_id = Column(Integer, index=True)&#10;    title = Column(String)&#10;    description = Column(Text)&#10;    event_date = Column(DateTime)&#10;    event_time = Column(String)&#10;    source_file = Column(String)&#10;    created_at = Column(DateTime, default=datetime.utcnow)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/models/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/schemas.py" />
              <option name="originalContent" value="from pydantic import BaseModel, EmailStr&#10;from datetime import datetime&#10;from typing import List&#10;&#10;class UserCreate(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;&#10;class UserLogin(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;&#10;class TelegramUserID(BaseModel):&#10;    telegram_user_id: str&#10;&#10;class EventResponse(BaseModel):&#10;    id: int&#10;    title: str&#10;    description: str&#10;    event_date: datetime&#10;    event_time: str&#10;    source_file: str&#10;&#10;class Token(BaseModel):&#10;    access_token: str&#10;    token_type: str&#10;&#10;class UserNotificationSettings(BaseModel):&#10;    notification_time: str  # Format: HH:MM (24-hour)&#10;    notify_one_day_before: bool&#10;&#10;class UserNotificationSettingsResponse(BaseModel):&#10;    notification_time: str&#10;    notify_one_day_before: bool&#10;" />
              <option name="updatedContent" value="from pydantic import BaseModel, EmailStr&#10;from datetime import datetime&#10;from typing import List&#10;&#10;class UserCreate(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;    role: str = &quot;person&quot;  # 'person', 'company_admin', 'company_member'&#10;    company_name: str = None  # Only for company_admin registration&#10;&#10;class UserLogin(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;&#10;class TelegramUserID(BaseModel):&#10;    telegram_user_id: str&#10;&#10;class EventResponse(BaseModel):&#10;    id: int&#10;    title: str&#10;    description: str&#10;    event_date: datetime&#10;    event_time: str&#10;    source_file: str&#10;&#10;class Token(BaseModel):&#10;    access_token: str&#10;    token_type: str&#10;&#10;class UserNotificationSettings(BaseModel):&#10;    notification_time: str  # Format: HH:MM (24-hour)&#10;    notify_one_day_before: bool&#10;&#10;class UserNotificationSettingsResponse(BaseModel):&#10;    notification_time: str&#10;    notify_one_day_before: bool&#10;&#10;class UserRole(BaseModel):&#10;    role: str&#10;&#10;class CompanyCreate(BaseModel):&#10;    name: str&#10;&#10;class CompanyContactCreate(BaseModel):&#10;    email: EmailStr = None&#10;    telegram_user_id: str = None&#10;&#10;class CompanyContactResponse(BaseModel):&#10;    id: int&#10;    email: EmailStr = None&#10;    telegram_user_id: str = None&#10;&#10;class CompanyResponse(BaseModel):&#10;    id: int&#10;    name: str&#10;    contacts: list[CompanyContactResponse] = []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="fastapi&#10;uvicorn[standard]&#10;sqlalchemy&#10;pydantic[email]&#10;python-multipart&#10;python-jose[cryptography]&#10;passlib[bcrypt]&#10;bcrypt&#10;python-telegram-bot&#10;requests&#10;pymupdf&#10;python-docx&#10;google-generativeai&#10;apscheduler&#10;pytz&#10;aiofiles&#10;pyjwt&#10;psycopg2-binary&#10;sendgrid" />
              <option name="updatedContent" value="fastapi&#10;uvicorn[standard]&#10;sqlalchemy&#10;pydantic[email]&#10;python-multipart&#10;python-jose[cryptography]&#10;passlib[bcrypt]&#10;bcrypt&#10;python-telegram-bot&#10;requests&#10;pymupdf&#10;python-docx&#10;google-generativeai&#10;apscheduler&#10;pytz&#10;aiofiles&#10;pyjwt&#10;psycopg2-binary&#10;sendgrid&#10;alembic" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/routers/auth.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/routers/auth.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException, status&#10;from sqlalchemy.orm import Session&#10;from models.db_models import User&#10;from models.schemas import UserCreate, UserLogin, Token, TelegramUserID&#10;from services.utils import hash_password, verify_password, create_access_token, get_current_user, get_database&#10;&#10;router = APIRouter(prefix=&quot;/auth&quot;, tags=[&quot;auth&quot;])&#10;&#10;@router.post(&quot;/register&quot;, response_model=Token)&#10;async def register(user: UserCreate, db: Session = Depends(get_database)):&#10;    existing_user = db.query(User).filter(User.email == user.email).first()&#10;    if existing_user:&#10;        raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)&#10;    hashed_password = hash_password(user.password)&#10;    db_user = User(email=user.email, hashed_password=hashed_password)&#10;    db.add(db_user)&#10;    db.commit()&#10;    db.refresh(db_user)&#10;    access_token = create_access_token(data={&quot;sub&quot;: user.email})&#10;    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}&#10;&#10;@router.post(&quot;/login&quot;, response_model=Token)&#10;async def login(user: UserLogin, db: Session = Depends(get_database)):&#10;    db_user = db.query(User).filter(User.email == user.email).first()&#10;    if not db_user or not verify_password(user.password, db_user.hashed_password):&#10;        raise HTTPException(status_code=401, detail=&quot;Invalid email or password&quot;)&#10;    access_token = create_access_token(data={&quot;sub&quot;: user.email})&#10;    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}&#10;&#10;@router.post(&quot;/telegram&quot;)&#10;async def set_telegram_user_id(telegram_data: TelegramUserID, current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    current_user.telegram_user_id = telegram_data.telegram_user_id&#10;    db.commit()&#10;    return {&quot;message&quot;: &quot;Telegram user ID updated successfully&quot;}&#10;&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException, status&#10;from sqlalchemy.orm import Session&#10;from models.db_models import User&#10;from models.schemas import UserCreate, UserLogin, Token, TelegramUserID&#10;from services.utils import hash_password, verify_password, create_access_token, get_current_user, get_database&#10;&#10;router = APIRouter(prefix=&quot;/auth&quot;, tags=[&quot;auth&quot;])&#10;&#10;@router.post(&quot;/register&quot;, response_model=Token)&#10;async def register(user: UserCreate, db: Session = Depends(get_database)):&#10;    existing_user = db.query(User).filter(User.email == user.email).first()&#10;    if existing_user:&#10;        raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)&#10;    hashed_password = hash_password(user.password)&#10;    if user.role == &quot;company_admin&quot;:&#10;        if not user.company_name:&#10;            raise HTTPException(status_code=400, detail=&quot;Company name is required for company_admin registration&quot;)&#10;        # Check if company already exists&#10;        existing_company = db.query(models.db_models.Company).filter(models.db_models.Company.name == user.company_name).first()&#10;        if existing_company:&#10;            raise HTTPException(status_code=400, detail=&quot;Company name already registered&quot;)&#10;        # Create company&#10;        company = models.db_models.Company(name=user.company_name)&#10;        db.add(company)&#10;        db.commit()&#10;        db.refresh(company)&#10;        db_user = User(email=user.email, hashed_password=hashed_password, role=&quot;company_admin&quot;, company_id=company.id)&#10;    else:&#10;        db_user = User(email=user.email, hashed_password=hashed_password, role=&quot;person&quot;)&#10;    db.add(db_user)&#10;    db.commit()&#10;    db.refresh(db_user)&#10;    access_token = create_access_token(data={&quot;sub&quot;: user.email})&#10;    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}&#10;&#10;@router.post(&quot;/login&quot;, response_model=Token)&#10;async def login(user: UserLogin, db: Session = Depends(get_database)):&#10;    db_user = db.query(User).filter(User.email == user.email).first()&#10;    if not db_user or not verify_password(user.password, db_user.hashed_password):&#10;        raise HTTPException(status_code=401, detail=&quot;Invalid email or password&quot;)&#10;    access_token = create_access_token(data={&quot;sub&quot;: user.email})&#10;    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}&#10;&#10;@router.post(&quot;/telegram&quot;)&#10;async def set_telegram_user_id(telegram_data: TelegramUserID, current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    current_user.telegram_user_id = telegram_data.telegram_user_id&#10;    db.commit()&#10;    return {&quot;message&quot;: &quot;Telegram user ID updated successfully&quot;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/routers/company.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/routers/company.py" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from models.db_models import User, CompanyContact&#10;from models.schemas import CompanyContactCreate, CompanyContactResponse&#10;from services.utils import get_current_user, get_database&#10;from typing import List&#10;&#10;router = APIRouter(prefix=&quot;/company&quot;, tags=[&quot;company&quot;])&#10;&#10;@router.get(&quot;/contacts&quot;, response_model=List[CompanyContactResponse])&#10;async def list_company_contacts(current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    if current_user.role != &quot;company_admin&quot; or not current_user.company_id:&#10;        raise HTTPException(status_code=403, detail=&quot;Only company admins can view company contacts.&quot;)&#10;    contacts = db.query(CompanyContact).filter(CompanyContact.company_id == current_user.company_id).all()&#10;    return contacts&#10;&#10;@router.post(&quot;/contacts&quot;, response_model=CompanyContactResponse)&#10;async def add_company_contact(contact: CompanyContactCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    if current_user.role != &quot;company_admin&quot; or not current_user.company_id:&#10;        raise HTTPException(status_code=403, detail=&quot;Only company admins can add company contacts.&quot;)&#10;    if not contact.email and not contact.telegram_user_id:&#10;        raise HTTPException(status_code=400, detail=&quot;At least one of email or telegram_user_id must be provided.&quot;)&#10;    new_contact = CompanyContact(&#10;        company_id=current_user.company_id,&#10;        email=contact.email,&#10;        telegram_user_id=contact.telegram_user_id&#10;    )&#10;    db.add(new_contact)&#10;    db.commit()&#10;    db.refresh(new_contact)&#10;    return new_contact&#10;&#10;@router.delete(&quot;/contacts/{contact_id}&quot;)&#10;async def delete_company_contact(contact_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    if current_user.role != &quot;company_admin&quot; or not current_user.company_id:&#10;        raise HTTPException(status_code=403, detail=&quot;Only company admins can delete company contacts.&quot;)&#10;    contact = db.query(CompanyContact).filter(CompanyContact.id == contact_id, CompanyContact.company_id == current_user.company_id).first()&#10;    if not contact:&#10;        raise HTTPException(status_code=404, detail=&quot;Contact not found.&quot;)&#10;    db.delete(contact)&#10;    db.commit()&#10;    return {&quot;message&quot;: &quot;Contact deleted successfully.&quot;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/routers/notification.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/routers/notification.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends&#10;from services.email_service import send_email&#10;from services.telegram_service import send_telegram_message&#10;from services.utils import get_current_user&#10;&#10;router = APIRouter(tags=[&quot;notification&quot;])&#10;&#10;@router.post(&quot;/test-notification&quot;)&#10;async def test_notification(current_user = Depends(get_current_user)):&#10;    await send_email(&#10;        current_user.email,&#10;        &quot;Test Notification&quot;,&#10;        &quot;&lt;h2&gt;Test Email&lt;/h2&gt;&lt;p&gt;This is a test notification from Schedule Management App.&lt;/p&gt;&quot;&#10;    )&#10;    if current_user.telegram_user_id:&#10;        await send_telegram_message(&#10;            current_user.telegram_user_id,&#10;            &quot; &lt;b&gt;Test Notification&lt;/b&gt;\n\nThis is a test notification from Schedule Management App.&quot;&#10;        )&#10;    return {&quot;message&quot;: &quot;Test notifications sent successfully&quot;}&#10;&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends&#10;from sqlalchemy.orm import Session&#10;&#10;from models.db_models import CompanyContact&#10;from services.email_service import send_email&#10;from services.telegram_service import send_telegram_message&#10;from services.utils import get_current_user, get_database&#10;&#10;router = APIRouter(tags=[&quot;notification&quot;])&#10;&#10;&#10;@router.post(&quot;/test-notification&quot;)&#10;async def test_notification(&#10;    current_user=Depends(get_current_user), db: Session = Depends(get_database)&#10;):&#10;    if current_user.role == &quot;company_admin&quot; and current_user.company_id:&#10;        contacts = (&#10;            db.query(CompanyContact)&#10;            .filter(CompanyContact.company_id == current_user.company_id)&#10;            .all()&#10;        )&#10;        for contact in contacts:&#10;            if contact.email:&#10;                await send_email(&#10;                    contact.email,&#10;                    &quot;Test Notification&quot;,&#10;                    &quot;&lt;h2&gt;Test Email&lt;/h2&gt;&lt;p&gt;This is a test notification from Schedule Management App.&lt;/p&gt;&quot;,&#10;                )&#10;            if contact.telegram_user_id:&#10;                await send_telegram_message(&#10;                    contact.telegram_user_id,&#10;                    &quot; &lt;b&gt;Test Notification&lt;/b&gt;\n\nThis is a test notification from Schedule Management App.&quot;,&#10;                )&#10;    else:&#10;        await send_email(&#10;            current_user.email,&#10;            &quot;Test Notification&quot;,&#10;            &quot;&lt;h2&gt;Test Email&lt;/h2&gt;&lt;p&gt;This is a test notification from Schedule Management App.&lt;/p&gt;&quot;,&#10;        )&#10;        if current_user.telegram_user_id:&#10;            await send_telegram_message(&#10;                current_user.telegram_user_id,&#10;                &quot; &lt;b&gt;Test Notification&lt;/b&gt;\n\nThis is a test notification from Schedule Management App.&quot;,&#10;            )&#10;    return {&quot;message&quot;: &quot;Test notifications sent successfully&quot;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/scheduler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/scheduler.py" />
              <option name="originalContent" value="from apscheduler.schedulers.background import BackgroundScheduler&#10;from apscheduler.triggers.cron import CronTrigger&#10;from datetime import datetime, timedelta, date, time as dt_time&#10;import pytz&#10;from config import TIMEZONE&#10;from models.db_models import User, Event&#10;from services.email_service import send_email&#10;from services.telegram_service import send_telegram_message&#10;from services.utils import SessionLocal&#10;import asyncio&#10;&#10;scheduler = BackgroundScheduler()&#10;&#10;# Helper to schedule notification jobs for each user&#10;async def send_user_notifications(user, notify_date, db, is_one_day_before=False):&#10;    # Get events for the notify_date&#10;    events = db.query(Event).filter(&#10;        Event.user_id == user.id,&#10;        Event.event_date &gt;= datetime.combine(notify_date, datetime.min.time()),&#10;        Event.event_date &lt; datetime.combine(notify_date + timedelta(days=1), datetime.min.time())&#10;    ).all()&#10;    if events:&#10;        day_label = notify_date.strftime('%B %d, %Y')&#10;        if is_one_day_before:&#10;            email_subject = f&quot;Tomorrow's Schedule - {day_label}&quot;&#10;            email_intro = f&quot;&lt;h2&gt;Tomorrow's Schedule - {day_label}&lt;/h2&gt;&lt;p&gt;Here are your events for tomorrow:&lt;/p&gt;&quot;&#10;            telegram_intro = f&quot; &lt;b&gt;Tomorrow's Schedule - {day_label}&lt;/b&gt;\n\n&quot;&#10;        else:&#10;            email_subject = f&quot;Today's Schedule - {day_label}&quot;&#10;            email_intro = f&quot;&lt;h2&gt;Today's Schedule - {day_label}&lt;/h2&gt;&lt;p&gt;Here are your events for today:&lt;/p&gt;&quot;&#10;            telegram_intro = f&quot; &lt;b&gt;Today's Schedule - {day_label}&lt;/b&gt;\n\n&quot;&#10;        email_body = f&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;{email_intro}&lt;ul&gt;&quot;&#10;        telegram_message = telegram_intro&#10;        for event in events:&#10;            email_body += f&quot;&lt;li&gt;&lt;strong&gt;{event.title}&lt;/strong&gt; at {event.event_time}&lt;br&gt;&lt;em&gt;{event.description}&lt;/em&gt;&lt;/li&gt;&quot;&#10;            telegram_message += f&quot; &lt;b&gt;{event.title}&lt;/b&gt; at {event.event_time}\n{event.description}\n\n&quot;&#10;        email_body += &quot;&lt;/ul&gt;&lt;p&gt;Have a great day!&lt;/p&gt;&lt;p&gt;&lt;em&gt;Schedule Management App&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#10;        await send_email(user.email, email_subject, email_body)&#10;        if user.telegram_user_id:&#10;            await send_telegram_message(user.telegram_user_id, telegram_message)&#10;&#10;async def notification_dispatcher():&#10;    db = SessionLocal()&#10;    try:&#10;        now = datetime.now(pytz.timezone(TIMEZONE))&#10;        users = db.query(User).filter(User.is_active == True).all()&#10;        for user in users:&#10;            # Parse user's notification_time&#10;            try:&#10;                user_hour, user_minute = map(int, user.notification_time.split(&quot;:&quot;))&#10;            except Exception:&#10;                user_hour, user_minute = 8, 0  # fallback&#10;            # If current time matches user's notification time, send today's events&#10;            if now.hour == user_hour and now.minute == user_minute:&#10;                await send_user_notifications(user, now.date(), db, is_one_day_before=False)&#10;            # If user wants one day before notification, check for that too&#10;            if user.notify_one_day_before:&#10;                # Send notification for tomorrow's events at user's notification time&#10;                tomorrow = now.date() + timedelta(days=1)&#10;                if now.hour == user_hour and now.minute == user_minute:&#10;                    await send_user_notifications(user, tomorrow, db, is_one_day_before=True)&#10;    finally:&#10;        db.close()&#10;&#10;def start_scheduler():&#10;    # Run notification_dispatcher every minute&#10;    scheduler.add_job(&#10;        lambda: asyncio.run(notification_dispatcher()),&#10;        CronTrigger(minute=&quot;*&quot;, timezone=pytz.timezone(TIMEZONE))&#10;    )&#10;    scheduler.start()&#10;" />
              <option name="updatedContent" value="from apscheduler.schedulers.background import BackgroundScheduler&#10;from apscheduler.triggers.cron import CronTrigger&#10;from datetime import datetime, timedelta, date, time as dt_time&#10;import pytz&#10;from config import TIMEZONE&#10;from models.db_models import User, Event, CompanyContact&#10;from services.email_service import send_email&#10;from services.telegram_service import send_telegram_message&#10;from services.utils import SessionLocal&#10;import asyncio&#10;&#10;scheduler = BackgroundScheduler()&#10;&#10;# Helper to schedule notification jobs for each user&#10;async def send_user_notifications(user, notify_date, db, is_one_day_before=False):&#10;    # Get events for the notify_date&#10;    events = db.query(Event).filter(&#10;        Event.user_id == user.id,&#10;        Event.event_date &gt;= datetime.combine(notify_date, datetime.min.time()),&#10;        Event.event_date &lt; datetime.combine(notify_date + timedelta(days=1), datetime.min.time())&#10;    ).all()&#10;    if events:&#10;        day_label = notify_date.strftime('%B %d, %Y')&#10;        if is_one_day_before:&#10;            email_subject = f&quot;Tomorrow's Schedule - {day_label}&quot;&#10;            email_intro = f&quot;&lt;h2&gt;Tomorrow's Schedule - {day_label}&lt;/h2&gt;&lt;p&gt;Here are your events for tomorrow:&lt;/p&gt;&quot;&#10;            telegram_intro = f&quot; &lt;b&gt;Tomorrow's Schedule - {day_label}&lt;/b&gt;\n\n&quot;&#10;        else:&#10;            email_subject = f&quot;Today's Schedule - {day_label}&quot;&#10;            email_intro = f&quot;&lt;h2&gt;Today's Schedule - {day_label}&lt;/h2&gt;&lt;p&gt;Here are your events for today:&lt;/p&gt;&quot;&#10;            telegram_intro = f&quot; &lt;b&gt;Today's Schedule - {day_label}&lt;/b&gt;\n\n&quot;&#10;        email_body = f&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;{email_intro}&lt;ul&gt;&quot;&#10;        telegram_message = telegram_intro&#10;        for event in events:&#10;            email_body += f&quot;&lt;li&gt;&lt;strong&gt;{event.title}&lt;/strong&gt; at {event.event_time}&lt;br&gt;&lt;em&gt;{event.description}&lt;/em&gt;&lt;/li&gt;&quot;&#10;            telegram_message += f&quot; &lt;b&gt;{event.title}&lt;/b&gt; at {event.event_time}\n{event.description}\n\n&quot;&#10;        email_body += &quot;&lt;/ul&gt;&lt;p&gt;Have a great day!&lt;/p&gt;&lt;p&gt;&lt;em&gt;Schedule Management App&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#10;        if user.role == &quot;company_admin&quot; and user.company_id:&#10;            contacts = db.query(CompanyContact).filter(CompanyContact.company_id == user.company_id).all()&#10;            for contact in contacts:&#10;                if contact.email:&#10;                    await send_email(contact.email, email_subject, email_body)&#10;                if contact.telegram_user_id:&#10;                    await send_telegram_message(contact.telegram_user_id, telegram_message)&#10;        else:&#10;            await send_email(user.email, email_subject, email_body)&#10;            if user.telegram_user_id:&#10;                await send_telegram_message(user.telegram_user_id, telegram_message)&#10;&#10;async def notification_dispatcher():&#10;    db = SessionLocal()&#10;    try:&#10;        now = datetime.now(pytz.timezone(TIMEZONE))&#10;        users = db.query(User).filter(User.is_active == True).all()&#10;        for user in users:&#10;            # Parse user's notification_time&#10;            try:&#10;                user_hour, user_minute = map(int, user.notification_time.split(&quot;:&quot;))&#10;            except Exception:&#10;                user_hour, user_minute = 8, 0  # fallback&#10;            # If current time matches user's notification time, send today's events&#10;            if now.hour == user_hour and now.minute == user_minute:&#10;                await send_user_notifications(user, now.date(), db, is_one_day_before=False)&#10;            # If user wants one day before notification, check for that too&#10;            if user.notify_one_day_before:&#10;                # Send notification for tomorrow's events at user's notification time&#10;                tomorrow = now.date() + timedelta(days=1)&#10;                if now.hour == user_hour and now.minute == user_minute:&#10;                    await send_user_notifications(user, tomorrow, db, is_one_day_before=True)&#10;    finally:&#10;        db.close()&#10;&#10;def start_scheduler():&#10;    # Run notification_dispatcher every minute&#10;    scheduler.add_job(&#10;        lambda: asyncio.run(notification_dispatcher()),&#10;        CronTrigger(minute=&quot;*&quot;, timezone=pytz.timezone(TIMEZONE))&#10;    )&#10;    scheduler.start()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>