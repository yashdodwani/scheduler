<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic.ini">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic.ini" />
              <option name="originalContent" value="# A generic, single database configuration.&#10;&#10;[alembic]&#10;# path to migration scripts.&#10;# this is typically a path given in POSIX (e.g. forward slashes)&#10;# format, relative to the token %(here)s which refers to the location of this&#10;# ini file&#10;script_location = %(here)s/alembic&#10;&#10;# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s&#10;# Uncomment the line below if you want the files to be prepended with date and time&#10;# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file&#10;# for all available tokens&#10;# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s&#10;&#10;# sys.path path, will be prepended to sys.path if present.&#10;# defaults to the current working directory.  for multiple paths, the path separator&#10;# is defined by &quot;path_separator&quot; below.&#10;prepend_sys_path = .&#10;&#10;&#10;# timezone to use when rendering the date within the migration file&#10;# as well as the filename.&#10;# If specified, requires the python&gt;=3.9 or backports.zoneinfo library and tzdata library.&#10;# Any required deps can installed by adding `alembic[tz]` to the pip requirements&#10;# string value is passed to ZoneInfo()&#10;# leave blank for localtime&#10;# timezone =&#10;&#10;# max length of characters to apply to the &quot;slug&quot; field&#10;# truncate_slug_length = 40&#10;&#10;# set to 'true' to run the environment during&#10;# the 'revision' command, regardless of autogenerate&#10;# revision_environment = false&#10;&#10;# set to 'true' to allow .pyc and .pyo files without&#10;# a source .py file to be detected as revisions in the&#10;# versions/ directory&#10;# sourceless = false&#10;&#10;# version location specification; This defaults&#10;# to &lt;script_location&gt;/versions.  When using multiple version&#10;# directories, initial revisions must be specified with --version-path.&#10;# The path separator used here should be the separator specified by &quot;path_separator&quot;&#10;# below.&#10;# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions&#10;&#10;# path_separator; This indicates what character is used to split lists of file&#10;# paths, including version_locations and prepend_sys_path within configparser&#10;# files such as alembic.ini.&#10;# The default rendered in new alembic.ini files is &quot;os&quot;, which uses os.pathsep&#10;# to provide os-dependent path splitting.&#10;#&#10;# Note that in order to support legacy alembic.ini files, this default does NOT&#10;# take place if path_separator is not present in alembic.ini.  If this&#10;# option is omitted entirely, fallback logic is as follows:&#10;#&#10;# 1. Parsing of the version_locations option falls back to using the legacy&#10;#    &quot;version_path_separator&quot; key, which if absent then falls back to the legacy&#10;#    behavior of splitting on spaces and/or commas.&#10;# 2. Parsing of the prepend_sys_path option falls back to the legacy&#10;#    behavior of splitting on spaces, commas, or colons.&#10;#&#10;# Valid values for path_separator are:&#10;#&#10;# path_separator = :&#10;# path_separator = ;&#10;# path_separator = space&#10;# path_separator = newline&#10;#&#10;# Use os.pathsep. Default configuration used for new projects.&#10;path_separator = os&#10;&#10;# set to 'true' to search source files recursively&#10;# in each &quot;version_locations&quot; directory&#10;# new in Alembic version 1.10&#10;# recursive_version_locations = false&#10;&#10;# the output encoding used when revision files&#10;# are written from script.py.mako&#10;# output_encoding = utf-8&#10;&#10;# database URL.  This is consumed by the user-maintained env.py script only.&#10;# other means of configuring database URLs may be customized within the env.py&#10;# file.&#10;sqlalchemy.url = driver://user:pass@localhost/dbname&#10;&#10;&#10;[post_write_hooks]&#10;# post_write_hooks defines scripts or Python functions that are run&#10;# on newly generated revision scripts.  See the documentation for further&#10;# detail and examples&#10;&#10;# format using &quot;black&quot; - use the console_scripts runner, against the &quot;black&quot; entrypoint&#10;# hooks = black&#10;# black.type = console_scripts&#10;# black.entrypoint = black&#10;# black.options = -l 79 REVISION_SCRIPT_FILENAME&#10;&#10;# lint with attempts to fix using &quot;ruff&quot; - use the module runner, against the &quot;ruff&quot; module&#10;# hooks = ruff&#10;# ruff.type = module&#10;# ruff.module = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Alternatively, use the exec runner to execute a binary found on your PATH&#10;# hooks = ruff&#10;# ruff.type = exec&#10;# ruff.executable = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Logging configuration.  This is also consumed by the user-maintained&#10;# env.py script only.&#10;[loggers]&#10;keys = root,sqlalchemy,alembic&#10;&#10;[handlers]&#10;keys = console&#10;&#10;[formatters]&#10;keys = generic&#10;&#10;[logger_root]&#10;level = WARNING&#10;handlers = console&#10;qualname =&#10;&#10;[logger_sqlalchemy]&#10;level = WARNING&#10;handlers =&#10;qualname = sqlalchemy.engine&#10;&#10;[logger_alembic]&#10;level = INFO&#10;handlers =&#10;qualname = alembic&#10;&#10;[handler_console]&#10;class = StreamHandler&#10;args = (sys.stderr,)&#10;level = NOTSET&#10;formatter = generic&#10;&#10;[formatter_generic]&#10;format = %(levelname)-5.5s [%(name)s] %(message)s&#10;datefmt = %H:%M:%S&#10;" />
              <option name="updatedContent" value="# A generic, single database configuration.&#10;&#10;[alembic]&#10;# path to migration scripts.&#10;# this is typically a path given in POSIX (e.g. forward slashes)&#10;# format, relative to the token %(here)s which refers to the location of this&#10;# ini file&#10;script_location = %(here)s/alembic&#10;&#10;# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s&#10;# Uncomment the line below if you want the files to be prepended with date and time&#10;# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file&#10;# for all available tokens&#10;# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s&#10;&#10;# sys.path path, will be prepended to sys.path if present.&#10;# defaults to the current working directory.  for multiple paths, the path separator&#10;# is defined by &quot;path_separator&quot; below.&#10;prepend_sys_path = .&#10;&#10;&#10;# timezone to use when rendering the date within the migration file&#10;# as well as the filename.&#10;# If specified, requires the python&gt;=3.9 or backports.zoneinfo library and tzdata library.&#10;# Any required deps can installed by adding `alembic[tz]` to the pip requirements&#10;# string value is passed to ZoneInfo()&#10;# leave blank for localtime&#10;# timezone =&#10;&#10;# max length of characters to apply to the &quot;slug&quot; field&#10;# truncate_slug_length = 40&#10;&#10;# set to 'true' to run the environment during&#10;# the 'revision' command, regardless of autogenerate&#10;# revision_environment = false&#10;&#10;# set to 'true' to allow .pyc and .pyo files without&#10;# a source .py file to be detected as revisions in the&#10;# versions/ directory&#10;# sourceless = false&#10;&#10;# version location specification; This defaults&#10;# to &lt;script_location&gt;/versions.  When using multiple version&#10;# directories, initial revisions must be specified with --version-path.&#10;# The path separator used here should be the separator specified by &quot;path_separator&quot;&#10;# below.&#10;# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions&#10;&#10;# path_separator; This indicates what character is used to split lists of file&#10;# paths, including version_locations and prepend_sys_path within configparser&#10;# files such as alembic.ini.&#10;# The default rendered in new alembic.ini files is &quot;os&quot;, which uses os.pathsep&#10;# to provide os-dependent path splitting.&#10;#&#10;# Note that in order to support legacy alembic.ini files, this default does NOT&#10;# take place if path_separator is not present in alembic.ini.  If this&#10;# option is omitted entirely, fallback logic is as follows:&#10;#&#10;# 1. Parsing of the version_locations option falls back to using the legacy&#10;#    &quot;version_path_separator&quot; key, which if absent then falls back to the legacy&#10;#    behavior of splitting on spaces and/or commas.&#10;# 2. Parsing of the prepend_sys_path option falls back to the legacy&#10;#    behavior of splitting on spaces, commas, or colons.&#10;#&#10;# Valid values for path_separator are:&#10;#&#10;# path_separator = :&#10;# path_separator = ;&#10;# path_separator = space&#10;# path_separator = newline&#10;#&#10;# Use os.pathsep. Default configuration used for new projects.&#10;path_separator = os&#10;&#10;# set to 'true' to search source files recursively&#10;# in each &quot;version_locations&quot; directory&#10;# new in Alembic version 1.10&#10;# recursive_version_locations = false&#10;&#10;# the output encoding used when revision files&#10;# are written from script.py.mako&#10;# output_encoding = utf-8&#10;&#10;# database URL.  This is consumed by the user-maintained env.py script only.&#10;# other means of configuring database URLs may be customized within the env.py&#10;# file.&#10;sqlalchemy.url =&#10;&#10;[post_write_hooks]&#10;# post_write_hooks defines scripts or Python functions that are run&#10;# on newly generated revision scripts.  See the documentation for further&#10;# detail and examples&#10;&#10;# format using &quot;black&quot; - use the console_scripts runner, against the &quot;black&quot; entrypoint&#10;# hooks = black&#10;# black.type = console_scripts&#10;# black.entrypoint = black&#10;# black.options = -l 79 REVISION_SCRIPT_FILENAME&#10;&#10;# lint with attempts to fix using &quot;ruff&quot; - use the module runner, against the &quot;ruff&quot; module&#10;# hooks = ruff&#10;# ruff.type = module&#10;# ruff.module = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Alternatively, use the exec runner to execute a binary found on your PATH&#10;# hooks = ruff&#10;# ruff.type = exec&#10;# ruff.executable = ruff&#10;# ruff.options = check --fix REVISION_SCRIPT_FILENAME&#10;&#10;# Logging configuration.  This is also consumed by the user-maintained&#10;# env.py script only.&#10;[loggers]&#10;keys = root,sqlalchemy,alembic&#10;&#10;[handlers]&#10;keys = console&#10;&#10;[formatters]&#10;keys = generic&#10;&#10;[logger_root]&#10;level = WARNING&#10;handlers = console&#10;qualname =&#10;&#10;[logger_sqlalchemy]&#10;level = WARNING&#10;handlers =&#10;qualname = sqlalchemy.engine&#10;&#10;[logger_alembic]&#10;level = INFO&#10;handlers =&#10;qualname = alembic&#10;&#10;[handler_console]&#10;class = StreamHandler&#10;args = (sys.stderr,)&#10;level = NOTSET&#10;formatter = generic&#10;&#10;[formatter_generic]&#10;format = %(levelname)-5.5s [%(name)s] %(message)s&#10;datefmt = %H:%M:%S" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/alembic/env.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/env.py" />
              <option name="originalContent" value="from logging.config import fileConfig&#10;&#10;from sqlalchemy import engine_from_config&#10;from sqlalchemy import pool&#10;&#10;from alembic import context&#10;&#10;# this is the Alembic Config object, which provides&#10;# access to the values within the .ini file in use.&#10;config = context.config&#10;&#10;# Interpret the config file for Python logging.&#10;# This line sets up loggers basically.&#10;if config.config_file_name is not None:&#10;    fileConfig(config.config_file_name)&#10;&#10;# add your model's MetaData object here&#10;# for 'autogenerate' support&#10;# from myapp import mymodel&#10;# target_metadata = mymodel.Base.metadata&#10;target_metadata = None&#10;&#10;# other values from the config, defined by the needs of env.py,&#10;# can be acquired:&#10;# my_important_option = config.get_main_option(&quot;my_important_option&quot;)&#10;# ... etc.&#10;&#10;&#10;def run_migrations_offline() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'offline' mode.&#10;&#10;    This configures the context with just a URL&#10;    and not an Engine, though an Engine is acceptable&#10;    here as well.  By skipping the Engine creation&#10;    we don't even need a DBAPI to be available.&#10;&#10;    Calls to context.execute() here emit the given string to the&#10;    script output.&#10;&#10;    &quot;&quot;&quot;&#10;    url = config.get_main_option(&quot;sqlalchemy.url&quot;)&#10;    context.configure(&#10;        url=url,&#10;        target_metadata=target_metadata,&#10;        literal_binds=True,&#10;        dialect_opts={&quot;paramstyle&quot;: &quot;named&quot;},&#10;    )&#10;&#10;    with context.begin_transaction():&#10;        context.run_migrations()&#10;&#10;&#10;def run_migrations_online() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'online' mode.&#10;&#10;    In this scenario we need to create an Engine&#10;    and associate a connection with the context.&#10;&#10;    &quot;&quot;&quot;&#10;    connectable = engine_from_config(&#10;        config.get_section(config.config_ini_section, {}),&#10;        prefix=&quot;sqlalchemy.&quot;,&#10;        poolclass=pool.NullPool,&#10;    )&#10;&#10;    with connectable.connect() as connection:&#10;        context.configure(&#10;            connection=connection, target_metadata=target_metadata&#10;        )&#10;&#10;        with context.begin_transaction():&#10;            context.run_migrations()&#10;&#10;&#10;if context.is_offline_mode():&#10;    run_migrations_offline()&#10;else:&#10;    run_migrations_online()&#10;" />
              <option name="updatedContent" value="from logging.config import fileConfig&#10;&#10;from sqlalchemy import engine_from_config&#10;from sqlalchemy import pool&#10;&#10;from alembic import context&#10;import sys&#10;import os&#10;&#10;# this is the Alembic Config object, which provides&#10;# access to the values within the .ini file in use.&#10;config = context.config&#10;&#10;sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))&#10;from config import SQLALCHEMY_DATABASE_URL&#10;from models.db_models import Base  # Import your Base&#10;config.set_main_option('sqlalchemy.url', SQLALCHEMY_DATABASE_URL)&#10;&#10;# Interpret the config file for Python logging.&#10;# This line sets up loggers basically.&#10;if config.config_file_name is not None:&#10;    fileConfig(config.config_file_name)&#10;&#10;# add your model's MetaData object here&#10;# for 'autogenerate' support&#10;# from myapp import mymodel&#10;# target_metadata = mymodel.Base.metadata&#10;target_metadata = Base.metadata&#10;&#10;# other values from the config, defined by the needs of env.py,&#10;# can be acquired:&#10;# my_important_option = config.get_main_option(&quot;my_important_option&quot;)&#10;# ... etc.&#10;&#10;&#10;def run_migrations_offline() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'offline' mode.&#10;&#10;    This configures the context with just a URL&#10;    and not an Engine, though an Engine is acceptable&#10;    here as well.  By skipping the Engine creation&#10;    we don't even need a DBAPI to be available.&#10;&#10;    Calls to context.execute() here emit the given string to the&#10;    script output.&#10;&#10;    &quot;&quot;&quot;&#10;    url = config.get_main_option(&quot;sqlalchemy.url&quot;)&#10;    context.configure(&#10;        url=url,&#10;        target_metadata=target_metadata,&#10;        literal_binds=True,&#10;        dialect_opts={&quot;paramstyle&quot;: &quot;named&quot;},&#10;    )&#10;&#10;    with context.begin_transaction():&#10;        context.run_migrations()&#10;&#10;&#10;def run_migrations_online() -&gt; None:&#10;    &quot;&quot;&quot;Run migrations in 'online' mode.&#10;&#10;    In this scenario we need to create an Engine&#10;    and associate a connection with the context.&#10;&#10;    &quot;&quot;&quot;&#10;    connectable = engine_from_config(&#10;        config.get_section(config.config_ini_section, {}),&#10;        prefix=&quot;sqlalchemy.&quot;,&#10;        poolclass=pool.NullPool,&#10;    )&#10;&#10;    with connectable.connect() as connection:&#10;        context.configure(&#10;            connection=connection, target_metadata=target_metadata&#10;        )&#10;&#10;        with context.begin_transaction():&#10;            context.run_migrations()&#10;&#10;&#10;if context.is_offline_mode():&#10;    run_migrations_offline()&#10;else:&#10;    run_migrations_online()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/models/db_models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/db_models.py" />
              <option name="originalContent" value="from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from datetime import datetime&#10;&#10;Base = declarative_base()&#10;&#10;class User(Base):&#10;    __tablename__ = &quot;users&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    email = Column(String, unique=True, index=True)&#10;    hashed_password = Column(String)&#10;    telegram_user_id = Column(String, nullable=True)&#10;    is_active = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    notification_time = Column(String, default=&quot;08:00&quot;)  # Format: HH:MM (24-hour)&#10;    notify_one_day_before = Column(Boolean, default=False)&#10;&#10;class Event(Base):&#10;    __tablename__ = &quot;events&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    user_id = Column(Integer, index=True)&#10;    title = Column(String)&#10;    description = Column(Text)&#10;    event_date = Column(DateTime)&#10;    event_time = Column(String)&#10;    source_file = Column(String)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;" />
              <option name="updatedContent" value="from sqlalchemy import Column, Integer, String, DateTime, Text, Boolean, ForeignKey&#10;from sqlalchemy.ext.declarative import declarative_base&#10;from sqlalchemy.orm import relationship&#10;from datetime import datetime&#10;&#10;Base = declarative_base()&#10;&#10;class Company(Base):&#10;    __tablename__ = &quot;companies&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    name = Column(String, unique=True, index=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    contacts = relationship(&quot;CompanyContact&quot;, back_populates=&quot;company&quot;)&#10;    users = relationship(&quot;User&quot;, back_populates=&quot;company&quot;)&#10;&#10;class CompanyContact(Base):&#10;    __tablename__ = &quot;company_contacts&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    company_id = Column(Integer, ForeignKey(&quot;companies.id&quot;))&#10;    email = Column(String, nullable=True)&#10;    telegram_user_id = Column(String, nullable=True)&#10;    company = relationship(&quot;Company&quot;, back_populates=&quot;contacts&quot;)&#10;&#10;class User(Base):&#10;    __tablename__ = &quot;users&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    email = Column(String, unique=True, index=True)&#10;    hashed_password = Column(String)&#10;    telegram_user_id = Column(String, nullable=True)&#10;    is_active = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=datetime.utcnow)&#10;    notification_time = Column(String, default=&quot;08:00&quot;)  # Format: HH:MM (24-hour)&#10;    notify_one_day_before = Column(Boolean, default=False)&#10;    role = Column(String, default=&quot;person&quot;)  # 'person', 'company_admin', 'company_member'&#10;    company_id = Column(Integer, ForeignKey(&quot;companies.id&quot;), nullable=True)&#10;    company = relationship(&quot;Company&quot;, back_populates=&quot;users&quot;)&#10;&#10;class Event(Base):&#10;    __tablename__ = &quot;events&quot;&#10;    id = Column(Integer, primary_key=True, index=True)&#10;    user_id = Column(Integer, index=True)&#10;    title = Column(String)&#10;    description = Column(Text)&#10;    event_date = Column(DateTime)&#10;    event_time = Column(String)&#10;    source_file = Column(String)&#10;    created_at = Column(DateTime, default=datetime.utcnow)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/models/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/schemas.py" />
              <option name="originalContent" value="from pydantic import BaseModel, EmailStr&#10;from datetime import datetime&#10;from typing import List&#10;&#10;class UserCreate(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;&#10;class UserLogin(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;&#10;class TelegramUserID(BaseModel):&#10;    telegram_user_id: str&#10;&#10;class EventResponse(BaseModel):&#10;    id: int&#10;    title: str&#10;    description: str&#10;    event_date: datetime&#10;    event_time: str&#10;    source_file: str&#10;&#10;class Token(BaseModel):&#10;    access_token: str&#10;    token_type: str&#10;&#10;class UserNotificationSettings(BaseModel):&#10;    notification_time: str  # Format: HH:MM (24-hour)&#10;    notify_one_day_before: bool&#10;&#10;class UserNotificationSettingsResponse(BaseModel):&#10;    notification_time: str&#10;    notify_one_day_before: bool&#10;" />
              <option name="updatedContent" value="from pydantic import BaseModel, EmailStr&#10;from datetime import datetime&#10;from typing import List&#10;&#10;class UserCreate(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;    role: str = &quot;person&quot;  # 'person', 'company_admin', 'company_member'&#10;    company_name: str = None  # Only for company_admin registration&#10;&#10;class UserLogin(BaseModel):&#10;    email: EmailStr&#10;    password: str&#10;&#10;class TelegramUserID(BaseModel):&#10;    telegram_user_id: str&#10;&#10;class EventResponse(BaseModel):&#10;    id: int&#10;    title: str&#10;    description: str&#10;    event_date: datetime&#10;    event_time: str&#10;    source_file: str&#10;&#10;class Token(BaseModel):&#10;    access_token: str&#10;    token_type: str&#10;&#10;class UserNotificationSettings(BaseModel):&#10;    notification_time: str  # Format: HH:MM (24-hour)&#10;    notify_one_day_before: bool&#10;&#10;class UserNotificationSettingsResponse(BaseModel):&#10;    notification_time: str&#10;    notify_one_day_before: bool&#10;&#10;class UserRole(BaseModel):&#10;    role: str&#10;&#10;class CompanyCreate(BaseModel):&#10;    name: str&#10;&#10;class CompanyContactCreate(BaseModel):&#10;    email: EmailStr = None&#10;    telegram_user_id: str = None&#10;&#10;class CompanyContactResponse(BaseModel):&#10;    id: int&#10;    email: EmailStr = None&#10;    telegram_user_id: str = None&#10;&#10;class CompanyResponse(BaseModel):&#10;    id: int&#10;    name: str&#10;    contacts: list[CompanyContactResponse] = []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="fastapi&#10;uvicorn[standard]&#10;sqlalchemy&#10;pydantic[email]&#10;python-multipart&#10;python-jose[cryptography]&#10;passlib[bcrypt]&#10;bcrypt&#10;python-telegram-bot&#10;requests&#10;pymupdf&#10;python-docx&#10;google-generativeai&#10;apscheduler&#10;pytz&#10;aiofiles&#10;pyjwt&#10;psycopg2-binary&#10;sendgrid" />
              <option name="updatedContent" value="fastapi&#10;uvicorn[standard]&#10;sqlalchemy&#10;pydantic[email]&#10;python-multipart&#10;python-jose[cryptography]&#10;passlib[bcrypt]&#10;bcrypt&#10;python-telegram-bot&#10;requests&#10;pymupdf&#10;python-docx&#10;google-generativeai&#10;apscheduler&#10;pytz&#10;aiofiles&#10;pyjwt&#10;psycopg2-binary&#10;sendgrid&#10;alembic" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/routers/company.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/routers/company.py" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException&#10;from sqlalchemy.orm import Session&#10;from models.db_models import User, CompanyContact&#10;from models.schemas import CompanyContactCreate, CompanyContactResponse&#10;from services.utils import get_current_user, get_database&#10;from typing import List&#10;&#10;router = APIRouter(prefix=&quot;/company&quot;, tags=[&quot;company&quot;])&#10;&#10;@router.get(&quot;/contacts&quot;, response_model=List[CompanyContactResponse])&#10;async def list_company_contacts(current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    if current_user.role != &quot;company_admin&quot; or not current_user.company_id:&#10;        raise HTTPException(status_code=403, detail=&quot;Only company admins can view company contacts.&quot;)&#10;    contacts = db.query(CompanyContact).filter(CompanyContact.company_id == current_user.company_id).all()&#10;    return contacts&#10;&#10;@router.post(&quot;/contacts&quot;, response_model=CompanyContactResponse)&#10;async def add_company_contact(contact: CompanyContactCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    if current_user.role != &quot;company_admin&quot; or not current_user.company_id:&#10;        raise HTTPException(status_code=403, detail=&quot;Only company admins can add company contacts.&quot;)&#10;    if not contact.email and not contact.telegram_user_id:&#10;        raise HTTPException(status_code=400, detail=&quot;At least one of email or telegram_user_id must be provided.&quot;)&#10;    new_contact = CompanyContact(&#10;        company_id=current_user.company_id,&#10;        email=contact.email,&#10;        telegram_user_id=contact.telegram_user_id&#10;    )&#10;    db.add(new_contact)&#10;    db.commit()&#10;    db.refresh(new_contact)&#10;    return new_contact&#10;&#10;@router.delete(&quot;/contacts/{contact_id}&quot;)&#10;async def delete_company_contact(contact_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_database)):&#10;    if current_user.role != &quot;company_admin&quot; or not current_user.company_id:&#10;        raise HTTPException(status_code=403, detail=&quot;Only company admins can delete company contacts.&quot;)&#10;    contact = db.query(CompanyContact).filter(CompanyContact.id == contact_id, CompanyContact.company_id == current_user.company_id).first()&#10;    if not contact:&#10;        raise HTTPException(status_code=404, detail=&quot;Contact not found.&quot;)&#10;    db.delete(contact)&#10;    db.commit()&#10;    return {&quot;message&quot;: &quot;Contact deleted successfully.&quot;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>